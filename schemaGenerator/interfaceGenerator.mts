/* eslint-disable @typescript-eslint/naming-convention */
import { readFileSync, writeFileSync } from 'fs';
import { InputData, jsonInputForTargetLanguage, quicktype, TypeScriptTargetLanguage } from 'quicktype-core';

interface InterfaceGenerationOptions {
    schemaFile: string,
    outFile: string,
    topLevelName: string
}

type RawSchema = {
    [key: string]: RawSchema | null;
};

function addWithToSchemaRows(schema: RawSchema) {
    if (schema === null || schema === undefined) {
        return;
    }
    Object.keys(schema).forEach(key => {
        if (key === 'rows' && 'row' in schema.rows!) {
            schema.rows.with = Object.fromEntries(
                Object.entries(schema.rows.row!)
                    .map(([k, v]) => {
                        return [k, v];
                    })
            ) as unknown as RawSchema;
        }
        addWithToSchemaRows(schema[key]!);
    });
}

function generateInterfaces(options: InterfaceGenerationOptions) {
    (async () => {
        const schema = JSON.parse(readFileSync(options.schemaFile).toString());
        addWithToSchemaRows(schema);

        // TODO: Replace TypeScriptTargetLanguage with custom subclass to avoid need for manual string processing below
        const cypressTsLang = new TypeScriptTargetLanguage();
        const schemaInput = jsonInputForTargetLanguage(cypressTsLang);
        schemaInput.addSourceSync({
            name: options.topLevelName,
            samples: [JSON.stringify(schema)],
        });
        const inputData = new InputData();
        inputData.addInput(schemaInput);

        const final = await quicktype({
            inputData,
            outputFilename: options.outFile,
            lang: cypressTsLang,
            rendererOptions: {
                'just-types': true, // just-types?
                'acronym-style': 'camel',
                'nice-property-names': true,
            // topLevel: options.topLevelName,
            },
            combineClasses: false,
            leadingComments: [
                '/**',
                ' * WARNING:',
                ' * THIS FILE IS AUTOMATICALLY GENERATED BY {@link https://github.com/kinland/cypress-selector-shorthand}.',
                ' * DO NOT MODIFY IT OR CHANGES MAY BE OVERWRITTEN!',
                ' */',
            ],
        });

        let topLevel = true;
        let rowInterfaceName: string | null = null;
        let rowInterface: string[] = [];
        const rowInterfaceRegex = /^export interface (.*)Row \{/;

        // Replace the 'null' types with Cypress.Chainable<JQuery<HTMLElement>>
        final.lines = final.lines.flatMap(row => {
            let modifiedRow = row.replace(/^\/\/ /, ''); // Fix our multiline comment https://github.com/quicktype/quicktype/issues/2332
            if (modifiedRow.endsWith('null;')) {
                modifiedRow = modifiedRow.replace(/null;$/, 'Cypress.Chainable<JQuery<HTMLElement>>');
            } else if (topLevel || !modifiedRow.match(/^\s*with:/)) {
                modifiedRow = modifiedRow.replace(/(:\s*)([^;]+);$/, '$1Cypress.ChainableLike<JQuery<HTMLElement>, $2>;');
            } else if (!topLevel) {
                modifiedRow = modifiedRow.replace(/^(\s*with:\s*)(.*)Row;$/, '$1$2With;');
            }

            rowInterfaceName ??= row.match(rowInterfaceRegex)?.[1] ?? null;
            if (rowInterfaceName !== null) {
                rowInterface.push(
                    row
                        .replace(rowInterfaceRegex, 'export interface $1With {')
                        .replace(/null;$/, `(text: string) => Cypress.ChainableLike<JQuery<HTMLElement>, ${rowInterfaceName}Row>;`)
                );
            }

            if (row.endsWith('}')) {
                topLevel = false;
                rowInterfaceName = null;
            }

            if (rowInterfaceName === null && rowInterface.length > 0) {
                const result = [modifiedRow, '', ...rowInterface];
                rowInterface = [];
                return result;
            } else {
                return modifiedRow;
            }
        });

        writeFileSync(options.outFile, final.lines.join('\n'));
    })();
}

export { generateInterfaces };
export type { InterfaceGenerationOptions };
